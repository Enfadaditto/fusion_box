vale perfecto, para una primera version todo esto funciona a las mil maravillas, 
pero evidentemente no es aceptable que pueda no tener localmente los archivos de la fusion que quiero y me tenga que conformar, 
me gustaria saber con antelacion como es que se vera mi fusion cuando evolucione, por lo que vamos a pasar a la version 1.1.0:

CONVERSACION CON CLAUDE:


estoy buscando hacer una app que me ayude a decidir fusiones en pokemon infinite fusion, tengo un sistema de analisis de archivos locales y tal y la verdad funciona estupendamente, pero ahora mismo mi principal problema es la consistencia, por ejemplo:

Tengo un charizard x charizard, los dos evolucionados desde charmander
Tengo un ursaring x duskull, que capture como teddiursa x duskull
Tengo un snorlax x scolipede, que capture cada uno individualmente desde munchlax y venipede y fusione

En mis archivos internos tengo los spritesheets de charmander, charmeleon y charizard, tengo los de munchlax y snorlax, tengo los de venipede, pero no tengo los de  whirlpede, ni de scolipede, tengo teddiursa pero no ursaring y tengo de duskull y dusclops a pesar que no tengo dusclops, pero no tengo dusknoir.

Porque crees que pase esto? como puedo conseguir estos sprites?

Editar
El problema que describes es muy común en Pokémon Infinite Fusion y tiene que ver con cómo el juego genera y almacena los sprites de las fusiones. Te explico las posibles causas:

¿Por qué pasa esto?
Sprites generados dinámicamente: Infinite Fusion no tiene sprites pre-hechos para todas las combinaciones posibles (serían millones). Muchos se generan automáticamente combinando partes de los sprites base.
Sprites custom vs autogenerados: Algunos sprites son hechos por la comunidad y se descargan/guardan, mientras que otros se generan al vuelo y pueden no guardarse permanentemente.
Evoluciones capturadas vs evolucionadas: Cuando capturas un Pokémon ya evolucionado, el juego puede no generar los sprites de sus pre-evoluciones. Cuando evolucionas, sí los tiene porque ya los procesó.
Cache incompleto: El juego guarda sprites en cache según los vas necesitando, no todos de una vez.
Cómo conseguir los sprites faltantes:
Opción 1: Forzar la generación
Ve a la PC del juego y accede al "Fusion Calculator"
Busca manualmente las combinaciones que te faltan (ej: Teddiursa + Duskull)
Esto debería generar y guardar el sprite
Opción 2: Ubicación de sprites
Los sprites suelen estar en:

[Carpeta del juego]/Graphics/CustomBattlers/
[Carpeta del juego]/Graphics/Battlers/
Opción 3: Sprite Packs de la comunidad
Descarga sprite packs completos de la comunidad de Infinite Fusion
Están disponibles en el Discord oficial o Reddit del juego
Para tu app:
Podrías implementar un sistema que:

Detecte sprites faltantes
Use la API/base de datos de sprites de la comunidad
Genere placeholders o use sprites base cuando no estén disponibles
¿Quieres que te ayude a implementar alguna de estas soluciones en tu app?





y si hago una especie de cliente local para scrapear las fusiones¿? Estoy empleando flutter, como deberia implementarlo? idealmente, me gustaria sacarlo de la pagina oficial, que tiene su propia dex de fusiones, la URL que busco seria https://infinitefusiondex.com/details/76.413 como ejemplo (Golem + Ferroseed)
De aqui podria sacar ambas combinaciones AxB y BxA, por lo que el scraping seria la mitad de las combinaciones, como seria en rendimiento eso?

Editar
Excelente idea! Hacer scraping de la página oficial es una solución muy elegante. Te explico cómo implementarlo en Flutter:

Estructura recomendada
1. Dependencias necesarias
yaml
dependencies:
  http: ^1.1.0
  html: ^0.15.4
  dio: ^5.3.2  # Alternativa más robusta a http
2. Arquitectura del scraper
dart
class FusionScraper {
  static const String baseUrl = 'https://infinitefusiondex.com/details/';
  final Dio _dio = Dio();
  
  Future<FusionData> scrapeFusion(int pokeA, int pokeB) async {
    final url = '$baseUrl$pokeA.$pokeB';
    
    try {
      final response = await _dio.get(url);
      return _parseFusionPage(response.data, pokeA, pokeB);
    } catch (e) {
      throw FusionScrapingException('Error scraping $url: $e');
    }
  }
  
  FusionData _parseFusionPage(String html, int pokeA, int pokeB) {
    final document = parse(html);
    
    // Extraer sprites de ambas combinaciones
    final spriteAB = _extractSprite(document, 'fusion-sprite-ab');
    final spriteBA = _extractSprite(document, 'fusion-sprite-ba');
    
    return FusionData(
      pokeA: pokeA,
      pokeB: pokeB,
      spriteAB: spriteAB,
      spriteBA: spriteBA,
      stats: _extractStats(document),
      types: _extractTypes(document),
    );
  }
}
3. Sistema de descarga masiva con control de rendimiento
dart
class BulkFusionDownloader {
  final FusionScraper _scraper = FusionScraper();
  final int maxConcurrentDownloads;
  final Duration delayBetweenRequests;
  
  BulkFusionDownloader({
    this.maxConcurrentDownloads = 5,
    this.delayBetweenRequests = const Duration(milliseconds: 100),
  });
  
  Future<void> downloadAllFusions() async {
    const totalPokemon = 468; // Número total en Infinite Fusion
    final combinations = _generateCombinations(totalPokemon);
    
    // Procesar en lotes para no sobrecargar el servidor
    final batches = _createBatches(combinations, maxConcurrentDownloads);
    
    for (int i = 0; i < batches.length; i++) {
      await Future.wait(
        batches[i].map((combo) => _downloadWithRetry(combo)),
      );
      
      // Delay entre lotes
      if (i < batches.length - 1) {
        await Future.delayed(delayBetweenRequests);
      }
      
      // Progreso
      print('Batch ${i + 1}/${batches.length} completed');
    }
  }
  
  List<Combination> _generateCombinations(int totalPokemon) {
    List<Combination> combinations = [];
    
    // Solo necesitas la mitad gracias a que sacas A×B y B×A de una vez
    for (int a = 1; a <= totalPokemon; a++) {
      for (int b = a + 1; b <= totalPokemon; b++) {
        combinations.add(Combination(a, b));
      }
    }
    
    return combinations;
  }
}
Optimizaciones de rendimiento
1. Cache y persistencia
dart
class FusionCache {
  static const String cacheDir = 'fusion_cache';
  
  Future<void> cacheFusion(FusionData fusion) async {
    final file = File('$cacheDir/${fusion.pokeA}_${fusion.pokeB}.json');
    await file.writeAsString(jsonEncode(fusion.toJson()));
  }
  
  Future<FusionData?> getCachedFusion(int pokeA, int pokeB) async {
    final file = File('$cacheDir/${pokeA}_${pokeB}.json');
    if (await file.exists()) {
      final json = await file.readAsString();
      return FusionData.fromJson(jsonDecode(json));
    }
    return null;
  }
}
2. Sistema de prioridades
dart
class PriorityDownloader {
  // Descarga primero las fusiones que el usuario tiene
  Future<void> downloadUserFusions(List<UserPokemon> userPokemon) async {
    for (final pokemon in userPokemon) {
      await _scraper.scrapeFusion(pokemon.headId, pokemon.bodyId);
    }
  }
  
  // Luego descarga el resto en background
  Future<void> downloadRemainingFusions() async {
    // Lógica para descargar las restantes
  }
}
Análisis de rendimiento
Números estimados:
Total de Pokémon: ~468
Combinaciones únicas: 468 × 467 ÷ 2 = ~109,356 requests
Con 100ms de delay: ~3 horas de descarga total
Con 5 requests concurrentes: ~36 minutos
Estrategias de optimización:
Descarga incremental: Solo lo que el usuario necesita
Background sync: Descarga completa en segundo plano
Compresión: Comprimir imágenes antes de guardar
Base de datos local: SQLite para búsquedas rápidas
3. UI con progreso
dart
class DownloadProgressWidget extends StatefulWidget {
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<DownloadProgress>(
      stream: downloader.progressStream,
      builder: (context, snapshot) {
        if (!snapshot.hasData) return CircularProgressIndicator();
        
        final progress = snapshot.data!;
        return Column(
          children: [
            LinearProgressIndicator(
              value: progress.percentage,
            ),
            Text('${progress.completed}/${progress.total} fusiones descargadas'),
            Text('ETA: ${progress.estimatedTimeRemaining}'),
          ],
        );
      },
    );
  }
}
¿Te parece bien esta aproximación? ¿Quieres que profundice en alguna parte específica, como el parsing HTML o el sistema de cache?





nonono, no digo scrapear TODO ahora mismo, son 3h eso, no quiero que me denuncien tampoco, no, lo que quiero que scrapear en tiempo de ejecucion las fusiones que quiero ver y almacenar estas en algun directorio de mi app para poder acceder a estas antes de scrapear, basicamente que el scrapping sea como el fallback

Editar
¡Ah perfecto! Un sistema de cache inteligente con scraping como fallback. Mucho más eficiente y respetuoso. Te muestro cómo implementarlo:

Estructura del sistema cache-first
1. Manager principal con fallback
dart
class FusionImageManager {
  final FusionCache _cache = FusionCache();
  final FusionScraper _scraper = FusionScraper();
  
  Future<FusionImages> getFusionImages(int pokeA, int pokeB) async {
    // 1. Intentar cache primero
    final cached = await _cache.getFusionImages(pokeA, pokeB);
    if (cached != null) {
      print('Cache hit: $pokeA × $pokeB');
      return cached;
    }
    
    // 2. Fallback: scraping
    print('Cache miss: scraping $pokeA × $pokeB');
    final scraped = await _scraper.scrapeFusion(pokeA, pokeB);
    
    // 3. Guardar en cache para próximas veces
    await _cache.saveFusionImages(scraped);
    
    return scraped;
  }
}
2. Sistema de cache local
dart
class FusionCache {
  static Future<String> get _cacheDir async {
    final appDir = await getApplicationDocumentsDirectory();
    final cacheDir = Directory('${appDir.path}/fusion_sprites');
    if (!await cacheDir.exists()) {
      await cacheDir.create(recursive: true);
    }
    return cacheDir.path;
  }
  
  Future<FusionImages?> getFusionImages(int pokeA, int pokeB) async {
    try {
      final dir = await _cacheDir;
      final fileAB = File('$dir/${pokeA}_${pokeB}_AB.png');
      final fileBA = File('$dir/${pokeA}_${pokeB}_BA.png');
      
      if (await fileAB.exists() && await fileBA.exists()) {
        return FusionImages(
          spriteAB: await fileAB.readAsBytes(),
          spriteBA: await fileBA.readAsBytes(),
          pokeA: pokeA,
          pokeB: pokeB,
          timestamp: await fileAB.lastModified(),
        );
      }
    } catch (e) {
      print('Error reading cache: $e');
    }
    return null;
  }
  
  Future<void> saveFusionImages(FusionImages fusion) async {
    try {
      final dir = await _cacheDir;
      final fileAB = File('$dir/${fusion.pokeA}_${fusion.pokeB}_AB.png');
      final fileBA = File('$dir/${fusion.pokeA}_${fusion.pokeB}_BA.png');
      
      await fileAB.writeAsBytes(fusion.spriteAB);
      await fileBA.writeAsBytes(fusion.spriteBA);
      
      print('Cached fusion: ${fusion.pokeA} × ${fusion.pokeB}');
    } catch (e) {
      print('Error saving to cache: $e');
    }
  }
}
3. Scraper optimizado para requests individuales
dart
class FusionScraper {
  static const String baseUrl = 'https://infinitefusiondex.com/details/';
  final Dio _dio = Dio(
    BaseOptions(
      connectTimeout: Duration(seconds: 10),
      receiveTimeout: Duration(seconds: 15),
      headers: {
        'User-Agent': 'FusionApp/1.0 (Flutter)',
      },
    ),
  );
  
  Future<FusionImages> scrapeFusion(int pokeA, int pokeB) async {
    final url = '$baseUrl$pokeA.$pokeB';
    
    try {
      final response = await _dio.get(url);
      return await _extractImages(response.data, pokeA, pokeB);
    } on DioException catch (e) {
      if (e.response?.statusCode == 404) {
        throw FusionNotFoundException('Fusion $pokeA×$pokeB not found');
      }
      throw FusionScrapingException('Network error: ${e.message}');
    }
  }
  
  Future<FusionImages> _extractImages(String html, int pokeA, int pokeB) async {
    final document = parse(html);
    
    // Buscar las URLs de las imágenes
    final imgAB = document.querySelector('.fusion-sprite-ab img')?.attributes['src'];
    final imgBA = document.querySelector('.fusion-sprite-ba img')?.attributes['src'];
    
    if (imgAB == null || imgBA == null) {
      throw FusionScrapingException('Could not find sprite URLs');
    }
    
    // Descargar las imágenes
    final spriteAB = await _downloadImage(imgAB);
    final spriteBA = await _downloadImage(imgBA);
    
    return FusionImages(
      spriteAB: spriteAB,
      spriteBA: spriteBA,
      pokeA: pokeA,
      pokeB: pokeB,
      timestamp: DateTime.now(),
    );
  }
  
  Future<Uint8List> _downloadImage(String url) async {
    final response = await _dio.get<Uint8List>(
      url.startsWith('http') ? url : 'https://infinitefusiondex.com$url',
      options: Options(responseType: ResponseType.bytes),
    );
    return response.data!;
  }
}
4. Widget que maneja loading y cache
dart
class FusionSpriteWidget extends StatefulWidget {
  final int pokeA, pokeB;
  final bool showAB; // true para A×B, false para B×A
  
  const FusionSpriteWidget({
    required this.pokeA,
    required this.pokeB,
    this.showAB = true,
    Key? key,
  }) : super(key: key);
  
  @override
  State<FusionSpriteWidget> createState() => _FusionSpriteWidgetState();
}

class _FusionSpriteWidgetState extends State<FusionSpriteWidget> {
  final FusionImageManager _manager = FusionImageManager();
  FusionImages? _fusion;
  bool _isLoading = false;
  String? _error;
  
  @override
  void initState() {
    super.initState();
    _loadFusion();
  }
  
  Future<void> _loadFusion() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });
    
    try {
      final fusion = await _manager.getFusionImages(widget.pokeA, widget.pokeB);
      setState(() {
        _fusion = fusion;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Container(
        width: 96,
        height: 96,
        child: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
    
    if (_error != null) {
      return Container(
        width: 96,
        height: 96,
        child: Icon(Icons.error),
      );
    }
    
    if (_fusion == null) return SizedBox.shrink();
    
    final imageBytes = widget.showAB ? _fusion!.spriteAB : _fusion!.spriteBA;
    
    return Image.memory(
      imageBytes,
      width: 96,
      height: 96,
      fit: BoxFit.cover,
    );
  }
}
5. Modelos de datos
dart
class FusionImages {
  final Uint8List spriteAB;
  final Uint8List spriteBA;
  final int pokeA, pokeB;
  final DateTime timestamp;
  
  FusionImages({
    required this.spriteAB,
    required this.spriteBA,
    required this.pokeA,
    required this.pokeB,
    required this.timestamp,
  });
}
Ventajas de este enfoque:
Instantáneo: Una vez cacheado, no hay delay
Respetuoso: Solo 1 request por fusión vista
Resiliente: Funciona offline para fusiones ya vistas
Escalable: Cache crece orgánicamente con el uso
¿Te parece bien esta implementación? ¿Quieres que ajuste algo específico?





no quiero requests individuales tampoco, osea puedo hacer scrapping de n/3 pokemon por ejemplo: 3 scrappers si hay 9 pokemon o algo asi

Editar
¡Ah perfecto! Un sistema de scraping inteligente que agrupa múltiples Pokémon en cada request. Mucho más eficiente. Te muestro cómo implementarlo:

Sistema de scraping por lotes
1. Manager con agrupación inteligente
dart
class BatchFusionManager {
  final FusionCache _cache = FusionCache();
  final BatchScraper _scraper = BatchScraper();
  final Map<String, Completer<FusionImages>> _pendingRequests = {};
  
  Future<FusionImages> getFusionImages(int pokeA, int pokeB) async {
    // 1. Verificar cache primero
    final cached = await _cache.getFusionImages(pokeA, pokeB);
    if (cached != null) {
      return cached;
    }
    
    // 2. Si ya hay un request pendiente para esta fusión, esperar
    final key = '${pokeA}_${pokeB}';
    if (_pendingRequests.containsKey(key)) {
      return await _pendingRequests[key]!.future;
    }
    
    // 3. Crear completer y agregarlo al batch
    final completer = Completer<FusionImages>();
    _pendingRequests[key] = completer;
    
    // 4. Programar batch scraping
    _scheduleBatchScraping();
    
    return await completer.future;
  }
  
  Timer? _batchTimer;
  static const Duration batchDelay = Duration(milliseconds: 500);
  
  void _scheduleBatchScraping() {
    _batchTimer?.cancel();
    _batchTimer = Timer(batchDelay, _executeBatch);
  }
  
  Future<void> _executeBatch() async {
    if (_pendingRequests.isEmpty) return;
    
    final currentBatch = Map<String, Completer<FusionImages>>.from(_pendingRequests);
    _pendingRequests.clear();
    
    try {
      // Agrupar por combinaciones que se pueden obtener del mismo scrape
      final batches = _groupIntoBatches(currentBatch.keys.toList());
      
      for (final batch in batches) {
        await _processBatch(batch, currentBatch);
      }
    } catch (e) {
      // En caso de error, completar todos con error
      for (final completer in currentBatch.values) {
        if (!completer.isCompleted) {
          completer.completeError(e);
        }
      }
    }
  }
}
2. Agrupador inteligente de combinaciones
dart
class BatchScraper {
  final Dio _dio = Dio();
  
  // Agrupa las fusiones que se pueden obtener del mismo scrape
  List<List<FusionPair>> _groupIntoBatches(List<String> pendingKeys) {
    Map<String, List<FusionPair>> scrapGroups = {};
    
    // Convertir keys a pares y agrupar por URL base
    for (final key in pendingKeys) {
      final parts = key.split('_');
      final pokeA = int.parse(parts[0]);
      final pokeB = int.parse(parts[1]);
      
      // Determinar qué URL necesitamos (siempre el menor.mayor)
      final urlKey = pokeA < pokeB ? '${pokeA}.${pokeB}' : '${pokeB}.${pokeA}';
      
      scrapGroups.putIfAbsent(urlKey, () => []);
      scrapGroups[urlKey]!.add(FusionPair(pokeA, pokeB));
    }
    
    // Dividir en batches de tamaño manageable
    const maxBatchSize = 3;
    List<List<FusionPair>> batches = [];
    
    final allPairs = scrapGroups.values.expand((x) => x).toList();
    for (int i = 0; i < allPairs.length; i += maxBatchSize) {
      final batch = allPairs.skip(i).take(maxBatchSize).toList();
      batches.add(batch);
    }
    
    return batches;
  }
  
  Future<Map<String, FusionImages>> scrapeBatch(List<FusionPair> batch) async {
    final results = <String, FusionImages>{};
    
    // Agrupar por URL única que necesitamos scrapear
    final urlGroups = <String, List<FusionPair>>{};
    
    for (final pair in batch) {
      final urlKey = pair.pokeA < pair.pokeB 
        ? '${pair.pokeA}.${pair.pokeB}' 
        : '${pair.pokeB}.${pair.pokeA}';
      
      urlGroups.putIfAbsent(urlKey, () => []);
      urlGroups[urlKey]!.add(pair);
    }
    
    // Hacer requests concurrentes para cada URL única
    final futures = urlGroups.entries.map((entry) async {
      final urlKey = entry.key;
      final pairs = entry.value;
      
      final scrapedData = await _scrapeSingleUrl(urlKey);
      
      // Distribuir los resultados a todos los pares que lo necesitan
      for (final pair in pairs) {
        final key = '${pair.pokeA}_${pair.pokeB}';
        results[key] = _extractCorrectOrientation(scrapedData, pair);
      }
    });
    
    await Future.wait(futures);
    return results;
  }
  
  Future<ScrapedFusionData> _scrapeSingleUrl(String urlKey) async {
    final url = 'https://infinitefusiondex.com/details/$urlKey';
    
    try {
      final response = await _dio.get(url);
      return await _parseAndDownloadImages(response.data, urlKey);
    } catch (e) {
      throw FusionScrapingException('Error scraping $url: $e');
    }
  }
  
  Future<ScrapedFusionData> _parseAndDownloadImages(String html, String urlKey) async {
    final document = parse(html);
    final parts = urlKey.split('.');
    final basePokeA = int.parse(parts[0]);
    final basePokeB = int.parse(parts[1]);
    
    // Encontrar URLs de imágenes
    final imgAB = document.querySelector('.fusion-ab img')?.attributes['src'];
    final imgBA = document.querySelector('.fusion-ba img')?.attributes['src'];
    
    if (imgAB == null || imgBA == null) {
      throw FusionScrapingException('Could not find sprite URLs');
    }
    
    // Descargar ambas imágenes concurrentemente
    final futures = await Future.wait([
      _downloadImage(imgAB),
      _downloadImage(imgBA),
    ]);
    
    return ScrapedFusionData(
      basePokeA: basePokeA,
      basePokeB: basePokeB,
      spriteAB: futures[0],
      spriteBA: futures[1],
    );
  }
  
  FusionImages _extractCorrectOrientation(ScrapedFusionData scraped, FusionPair requested) {
    // Si el request coincide con la orientación base, usar directo
    if (requested.pokeA == scraped.basePokeA && requested.pokeB == scraped.basePokeB) {
      return FusionImages(
        spriteAB: scraped.spriteAB,
        spriteBA: scraped.spriteBA,
        pokeA: requested.pokeA,
        pokeB: requested.pokeB,
        timestamp: DateTime.now(),
      );
    }
    
    // Si está invertido, intercambiar sprites
    return FusionImages(
      spriteAB: scraped.spriteBA, // Intercambiado
      spriteBA: scraped.spriteAB, // Intercambiado
      pokeA: requested.pokeA,
      pokeB: requested.pokeB,
      timestamp: DateTime.now(),
    );
  }
}
3. Procesamiento del batch en el manager
dart
Future<void> _processBatch(
  List<FusionPair> batch, 
  Map<String, Completer<FusionImages>> completers
) async {
  try {
    final results = await _scraper.scrapeBatch(batch);
    
    // Completar todos los completers con sus resultados
    for (final entry in results.entries) {
      final key = entry.key;
      final fusion = entry.value;
      
      // Guardar en cache
      await _cache.saveFusionImages(fusion);
      
      // Completar el request pendiente
      if (completers.containsKey(key) && !completers[key]!.isCompleted) {
        completers[key]!.complete(fusion);
      }
    }
  } catch (e) {
    // En caso de error, completar todos los pendientes con error
    for (final key in batch.map((p) => '${p.pokeA}_${p.pokeB}')) {
      if (completers.containsKey(key) && !completers[key]!.isCompleted) {
        completers[key]!.completeError(e);
      }
    }
  }
}
4. Modelos de datos auxiliares
dart
class FusionPair {
  final int pokeA, pokeB;
  FusionPair(this.pokeA, this.pokeB);
}

class ScrapedFusionData {
  final int basePokeA, basePokeB;
  final Uint8List spriteAB, spriteBA;
  
  ScrapedFusionData({
    required this.basePokeA,
    required this.basePokeB,
    required this.spriteAB,
    required this.spriteBA,
  });
}
5. Uso en tu UI
dart
// En tu widget, usar igual que antes:
class FusionGridWidget extends StatelessWidget {
  final List<Pokemon> pokemonList;
  
  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      itemCount: pokemonList.length,
      itemBuilder: (context, index) {
        final pokemon = pokemonList[index];
        
        // Estos se van a agrupar automáticamente en batches
        return FusionSpriteWidget(
          pokeA: pokemon.headId,
          pokeB: pokemon.bodyId,
          showAB: true,
        );
      },
    );
  }
}
Ventajas de este sistema:
Eficiente: Múltiples fusiones por request
Inteligente: Agrupa automáticamente requests similares
No-blocking: Los requests se acumulan y procesan en batch
Resiliente: Cache + fallback funciona igual que antes
Configurable: Puedes ajustar el tamaño del batch y delay
¿Te gusta esta aproximación? ¿Quieres que ajuste el tamaño de batch o el timing?


MI MENSAJE:

El orden de ejecucion va a ser tal que:

1.- Busca en la carpeta interna de la app destinada a guardar fusiones
    1.1.- LO ENCUENTRA
    1.2.- NO LO ENCUENTRA: -> 2

2.- Busca en local del juego (Si tiene la ruta del juego definida)
    2.1.- LO ENCUENTRA: Lo recorta y lo guarda en carpeta interna de la app
    2.2.- NO LO ENCUENTRA: -> 3

3.- Busca hacer scrapping con los datos relevantes de los pokemon de la Fusion
    3.1.- EL SPRITE ES CUSTOM: lo guarda en la carpeta interna de la app
    3.2.- EL SPRITE ES AUTOGENERADO: lo ignora