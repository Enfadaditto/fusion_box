// ignore_for_file: constant_identifier_names

import 'dart:io';
import 'dart:typed_data';
import 'package:fusion_box/core/errors/exceptions.dart';
import 'package:fusion_box/domain/entities/sprite_data.dart';
import 'package:image/image.dart' as img;

class SpriteParser {
  static const int SPRITE_WIDTH = 96;
  static const int SPRITE_HEIGHT = 96;
  static const int SPRITES_PER_ROW = 20;
  static const int AUTOGEN_SPRITES_PER_ROW =
      10; // Sprites autogenerados usan 10 por fila

  /// Extrae un sprite específico por índice sin parsear toda la imagen (OPTIMIZADO)
  Future<SpriteData?> extractSpriteByIndex(
    String spritesheetPath,
    int index,
    String variant, {
    bool isAutogenerated = false,
  }) async {
    try {
      final spriteSheet = File(spritesheetPath);
      if (!await spriteSheet.exists()) {
        return null;
      }

      final bytes = await spriteSheet.readAsBytes();
      final image = img.decodeImage(bytes);

      if (image == null) {
        return null;
      }

      // Usar diferentes sprites por fila dependiendo del tipo
      final spritesPerRow =
          isAutogenerated ? AUTOGEN_SPRITES_PER_ROW : SPRITES_PER_ROW;

      // Calcular la posición del sprite específico
      final col = index % spritesPerRow;
      final row = index ~/ spritesPerRow;

      final x = col * SPRITE_WIDTH;
      final y = row * SPRITE_HEIGHT;

      // Verificar que la posición está dentro de los límites
      if (x + SPRITE_WIDTH > image.width || y + SPRITE_HEIGHT > image.height) {
        return null;
      }

      // Extraer solo el sprite específico
      final sprite = img.copyCrop(
        image,
        x: x,
        y: y,
        width: SPRITE_WIDTH,
        height: SPRITE_HEIGHT,
      );

      if (!_isValidSprite(sprite)) {
        return null;
      }

      final spriteBytes = Uint8List.fromList(img.encodePng(sprite));

      return SpriteData(
        spritePath: spritesheetPath,
        spriteBytes: spriteBytes,
        x: x,
        y: y,
        width: SPRITE_WIDTH,
        height: SPRITE_HEIGHT,
        variant: variant,
        isAutogenerated: isAutogenerated,
      );
    } catch (e) {
      return null;
    }
  }

  /// Extrae un sprite específico por índice sin parsear toda la imagen (OPTIMIZADO)
  Future<SpriteData?> extractSpriteByIndexFromSpritesheet(
      String spritesheetPath,
      img.Image spritesheet,
      int index,
      String variant, {
      bool isAutogenerated = false,
  }) async {
    try {
      // Usar diferentes sprites por fila dependiendo del tipo
      final spritesPerRow =
      isAutogenerated ? AUTOGEN_SPRITES_PER_ROW : SPRITES_PER_ROW;

      // Calcular la posición del sprite específico
      final col = index % spritesPerRow;
      final row = index ~/ spritesPerRow;

      final x = col * SPRITE_WIDTH;
      final y = row * SPRITE_HEIGHT;

      // Verificar que la posición está dentro de los límites
      if (x + SPRITE_WIDTH > spritesheet.width || y + SPRITE_HEIGHT > spritesheet.height) {
        return null;
      }

      // Extraer solo el sprite específico
      final sprite = img.copyCrop(
        spritesheet,
        x: x,
        y: y,
        width: SPRITE_WIDTH,
        height: SPRITE_HEIGHT,
      );

      if (!_isValidSprite(sprite)) {
        return null;
      }

      final spriteBytes = Uint8List.fromList(img.encodePng(sprite));

      return SpriteData(
        spritePath: spritesheetPath,
        spriteBytes: spriteBytes,
        x: x,
        y: y,
        width: SPRITE_WIDTH,
        height: SPRITE_HEIGHT,
        variant: variant,
        isAutogenerated: isAutogenerated,
      );
    } catch (e) {
      return null;
    }
  }

  Future<List<SpriteData>> parseSpritesheetToSprites(
    String spriteSheetPath,
    String variant, {
    bool isAutogenerated = false,
  }) async {
    try {
      final spriteSheet = File(spriteSheetPath);
      if (!await spriteSheet.exists()) {
        throw SpriteNotFoundException(
          'Sprite sheet file not found: $spriteSheetPath',
        );
      }

      final bytes = await spriteSheet.readAsBytes();
      final image = img.decodeImage(bytes);

      if (image == null) {
        throw SpriteParseException('Could not decode sprite: $spriteSheetPath');
      }

      return _extractSpritesFromImage(
        image,
        spriteSheetPath,
        variant,
        isAutogenerated: isAutogenerated,
      );
    } catch (e) {
      throw SpriteParseException('Failed to parse sprite sheet: $e');
    }
  }

  List<SpriteData> _extractSpritesFromImage(
    img.Image sourceImage,
    String spriteSheetPath,
    String variant, {
    bool isAutogenerated = false,
  }) {
    final sprites = <SpriteData>[];
    final rows = sourceImage.height ~/ SPRITE_HEIGHT;
    final cols = sourceImage.width ~/ SPRITE_WIDTH;

    for (var row = 0; row < rows; row++) {
      for (var col = 0; col < cols; col++) {
        final x = col * SPRITE_WIDTH;
        final y = row * SPRITE_HEIGHT;

        final sprite = img.copyCrop(
          sourceImage,
          x: x,
          y: y,
          width: SPRITE_WIDTH,
          height: SPRITE_HEIGHT,
        );

        if (_isValidSprite(sprite)) {
          final spriteBytes = Uint8List.fromList(img.encodePng(sprite));
          sprites.add(
            SpriteData(
              spritePath: spriteSheetPath,
              spriteBytes: spriteBytes,
              x: x,
              y: y,
              width: SPRITE_WIDTH,
              height: SPRITE_HEIGHT,
              variant: variant,
              isAutogenerated: isAutogenerated,
            ),
          );
        }
      }
    }

    return sprites;
  }

  bool _isValidSprite(img.Image sprite) {
    for (int y = 0; y < sprite.height; y++) {
      for (int x = 0; x < sprite.width; x++) {
        final pixel = sprite.getPixel(x, y);
        if (pixel.a > 0) {
          return true;
        }
      }
    }
    return false;
  }
}
