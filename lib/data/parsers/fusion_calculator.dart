import 'dart:io';
import 'dart:async';

import 'package:fusion_box/core/errors/exceptions.dart';
import 'package:fusion_box/data/parsers/sprite_parser.dart';
import 'package:fusion_box/domain/entities/sprite_data.dart';
import 'package:fusion_box/data/datasources/local/game_local_datasource.dart';
import 'package:fusion_box/core/services/sprite_download_service.dart';
import 'package:image/image.dart' as img;
import 'package:path_provider/path_provider.dart';
import 'package:fusion_box/core/services/logger_service.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:fusion_box/config/app_config.dart';
import 'package:http/http.dart' as http;
import 'package:fusion_box/core/services/variants_cache_service.dart';
 

class FusionCalculator {
  final SpriteParser spriteParser;
  final GameLocalDataSource gameLocalDataSource;
  final SpriteDownloadService spriteDownloadService;
  final LoggerService logger;

  FusionCalculator({
    required this.spriteParser,
    required this.gameLocalDataSource,
    required this.spriteDownloadService,
    required this.logger,
  });

  Future<List<SpriteData>> getFusion(int headId, int bodyId) async {
    final sprites = <SpriteData>[];

    try {
      if (kIsWeb) {
        // En web, evitar IO y decodificación: calcular sub-rect y renderizar vía CSS/Transform
        final List<String> variants = [''];
        for (final variant in variants) {
          final base = AppConfig.customSpritesBaseUrlWeb;
          final url = '$base$headId/$headId$variant.png';
          // Calcular subrect del índice bodyId
          const int spriteWidth = SpriteParser.SPRITE_WIDTH;
          const int spriteHeight = SpriteParser.SPRITE_HEIGHT;
          const int spritesPerRow = SpriteParser.SPRITES_PER_ROW;
          final int col = bodyId % spritesPerRow;
          final int row = bodyId ~/ spritesPerRow;
          final int x = col * spriteWidth;
          final int y = row * spriteHeight;
          sprites.add(
            SpriteData(
              spritePath: url,
              spriteBytes: null,
              x: x,
              y: y,
              width: spriteWidth,
              height: spriteHeight,
              variant: variant,
              isAutogenerated: false,
            ),
          );
        }
      } else {
        final gameBasePath = await _getGameBasePath();
        final basePath = _buildSpritePath(gameBasePath, headId);
        // Obtener variantes desde el disco cada vez (sin caché de variantes)
        List<String> variants = await _getAvailableVariants(basePath);

        for (final variant in variants) {
          final spriteSheetPath = _buildFullSpritePath(basePath, variant);

          // Intentar descargar el spritesheet si no existe
          await _tryDownloadSpritesheet(headId, spriteSheetPath, variant);

          try {
            final variantSprites = await spriteParser.parseSpritesheetToSprites(
              spriteSheetPath,
              variant,
            );

            final relevantSprites = _filterSpritesByBodyId(
              variantSprites,
              bodyId,
            );

            sprites.addAll(relevantSprites);
          } catch (e, s) {
            await logger.logError(
              Exception('parseSpritesheetToSprites failed for headId=$headId bodyId=$bodyId variant=$variant path=$spriteSheetPath error=$e'),
              s,
            );
            continue;
          }
        }
      }

      // No actualizar caché de variantes

      return sprites;
    } catch (e, s) {
      await logger.logError(
        Exception('getFusion failed for headId=$headId bodyId=$bodyId error=$e'),
        s,
      );
      throw FusionCalculationException('Failed to calculate fusion: $headId-$bodyId: $e');
    }
  }

  Future<String> getFullSpritesheetPath(int headId) async {
    final gameBasePath = await _getGameBasePath();
    final basePath = _buildSpritePath(gameBasePath, headId);
    return _buildFullSpritePath(basePath, '');
  }

  Future<String> _getGameBasePath() async {
    if (!kIsWeb) {
      final path = await gameLocalDataSource.getGamePath();
      if (path != null && path.isNotEmpty) {
        return path;
      }

      final Directory appDir = await getApplicationSupportDirectory();
      final Directory spritesDir = Directory(
        '${appDir.path}/spritesheets_custom',
      );
      if (!await spritesDir.exists()) {
        await spritesDir.create(recursive: true);
      }
      return spritesDir.path;
    }

    // En web no usamos base path del sistema de archivos
    return '';
  }

  String _buildSpritePath(String gameBasePath, int headId) {
    return '$gameBasePath/Graphics/CustomBattlers/spritesheets/spritesheets_custom/$headId';
  }

  String _buildFullSpritePath(String basePath, String variant) {
    final headId = basePath.split('/').last;
    final suffix = variant.isEmpty ? '' : variant;
    return '$basePath/$headId$suffix.png';
  }

  Future<List<String>> _getAvailableVariants(String basePath) async {
    final variants = <String>[];
    if (kIsWeb) {
      // En web no listamos disco; intentamos usar caché y, si no existe, sondear variantes remotas
      final headId = int.tryParse(basePath.split('/').last) ?? 0;
      final cached = await VariantsCacheService.getCachedVariants(headId);
      if (cached != null && cached.isNotEmpty) {
        return cached;
      }

      final discovered = await _probeAvailableVariantsWeb(headId);
      if (discovered.isNotEmpty) {
        await VariantsCacheService.setCachedVariants(headId, discovered);
        return discovered;
      }

      // Fallback mínimo: solo la base
      return [''];
    }
    final headId = int.tryParse(basePath.split('/').last) ?? 0;
    final mainFile = File('$basePath/$headId.png');

    // Intentar descargar el sprite principal si no existe
    if (!await mainFile.exists()) {
      await _tryDownloadSpritesheet(headId, '$basePath/$headId.png', '');
    }

    if (await mainFile.exists()) {
      variants.add('');
    }

    final baseDir = Directory(basePath);
    if (await baseDir.exists()) {
      final entities = baseDir.listSync();
      final baseName = basePath.split('/').last;

      for (final entity in entities) {
        if (entity is File && entity.path.endsWith('.png')) {
          final fileName = entity.path.split('/').last.replaceAll('.png', '');
          if (fileName.startsWith(baseName)) {
            final suffix = fileName.substring(baseName.length);
            if (suffix.isEmpty) {
              // base already added above
              continue;
            }
            variants.add(suffix);
          }
        }
      }
    }

    // Sort with base first, then lexicographically to keep deterministic order
    variants.sort((a, b) {
      if (a.isEmpty && b.isNotEmpty) return -1;
      if (b.isEmpty && a.isNotEmpty) return 1;
      return a.compareTo(b);
    });

    return variants;
  }

  /// Public method to list available variant suffixes for a given headId by scanning disk.
  Future<List<String>> listAvailableVariants(int headId) async {
    final gameBasePath = await _getGameBasePath();
    final basePath = _buildSpritePath(gameBasePath, headId);
    return _getAvailableVariants(basePath);
  }

  /// Web-only: intenta descubrir variantes existentes probando URLs remotas con un HEAD/GET rápido.
  /// Devuelve lista con '' primero si la base existe.
  Future<List<String>> _probeAvailableVariantsWeb(int headId) async {
    if (!kIsWeb) return const <String>[];

    final List<String> found = <String>[];

    Future<bool> existsAt(String variant) async {
      try {
        final base = AppConfig.customSpritesBaseUrlWeb;
        final url = '$base$headId/$headId$variant.png';
        final uri = Uri.parse(url);
        // HEAD puede no estar permitido por proxy; usar GET con timeout corto
        final resp = await http
            .get(uri, headers: const {'Accept': 'image/png,image/*,*/*'})
            .timeout(const Duration(seconds: 6));
        if (resp.statusCode == 200 && (resp.headers['content-type'] ?? '').startsWith('image/')) {
          return true;
        }
      } catch (_) {}
      return false;
    }

    // Base
    if (await existsAt('')) {
      found.add('');
    }

    // Letras simples a..z
    for (int i = 0; i < 26; i++) {
      final v = String.fromCharCode('a'.codeUnitAt(0) + i);
      final ok = await existsAt(v);
      if (ok) found.add(v);
    }

    // Letras dobles aa..zz con early stop en rachas largas de misses
    int consecutiveMisses = 0;
    const int maxMisses = 40;
    for (int i = 0; i < 26; i++) {
      for (int j = 0; j < 26; j++) {
        final v = '${String.fromCharCode('a'.codeUnitAt(0) + i)}${String.fromCharCode('a'.codeUnitAt(0) + j)}';
        final ok = await existsAt(v);
        if (ok) {
          found.add(v);
          consecutiveMisses = 0;
        } else {
          consecutiveMisses++;
          if (consecutiveMisses >= maxMisses) {
            break;
          }
        }
      }
      if (consecutiveMisses >= maxMisses) break;
    }

    // Orden estable: base primero, resto ordenado
    final ordered = <String>[];
    if (found.contains('')) ordered.add('');
    ordered.addAll(found.where((v) => v.isNotEmpty).toSet().toList()..sort());
    return ordered;
  }

  List<SpriteData> _filterSpritesByBodyId(
    List<SpriteData> sprites,
    int bodyId,
  ) {
    if (bodyId < 0 || bodyId >= sprites.length) {
      return [];
    }

    return [sprites[bodyId]];
  }

  /// Obtiene un sprite específico para una fusión
  Future<SpriteData?> getSpecificFusionSprite(
    int headId,
    int bodyId, {
    String variant = '',
  }) async {
    String? debugSpritesheetPath;
    try {
      if (kIsWeb) {
        final base = AppConfig.customSpritesBaseUrlWeb;
        final url = '$base$headId/$headId$variant.png';
        debugSpritesheetPath = url;
        const int spriteWidth = SpriteParser.SPRITE_WIDTH;
        const int spriteHeight = SpriteParser.SPRITE_HEIGHT;
        const int spritesPerRow = SpriteParser.SPRITES_PER_ROW;
        final int col = bodyId % spritesPerRow;
        final int row = bodyId ~/ spritesPerRow;
        final int x = col * spriteWidth;
        final int y = row * spriteHeight;
        return SpriteData(
          spritePath: url,
          spriteBytes: null,
          x: x,
          y: y,
          width: spriteWidth,
          height: spriteHeight,
          variant: variant,
          isAutogenerated: false,
        );
      } else {
        final gameBasePath = await _getGameBasePath();
        final basePath = _buildSpritePath(gameBasePath, headId);
        final spritesheetPath = _buildFullSpritePath(basePath, variant);
        debugSpritesheetPath = spritesheetPath;

        // Intentar descargar el spritesheet si no existe
        await _tryDownloadSpritesheet(headId, spritesheetPath, variant);

        final sprite = await spriteParser.extractSpriteByIndex(
          spritesheetPath,
          bodyId,
          variant,
        );

        return sprite;
      }
    } catch (e, s) {
      await logger.logError(
        Exception('getSpecificFusionSprite failed for headId=$headId bodyId=$bodyId variant=$variant path=${debugSpritesheetPath ?? "<unknown>"} error=$e'),
        s,
      );
      return null;
    }
  }

  Future<SpriteData?> getSpecificFusionSpriteFromSpritesheet(
    String spritesheetPath,
    img.Image spritesheet,
    int headId,
    int bodyId, {
    String variant = '',
  }) async {
    try {
      final sprite = await spriteParser.extractSpriteByIndexFromSpritesheet(
        spritesheetPath,
        spritesheet,
        bodyId,
        variant,
      );

      return sprite;
    } catch (e, s) {
      await logger.logError(
        Exception('getSpecificFusionSpriteFromSpritesheet failed for headId=$headId bodyId=$bodyId variant=$variant path=${spritesheetPath} error=$e'),
        s,
      );
      return null;
    }
  }

  /// Obtiene un sprite autogenerado como fallback
  Future<SpriteData?> getAutogenSprite(int headId, int bodyId) async {
    try {
      if (kIsWeb) {
        // Web: no hay autogen real. Devolver SpriteData sin ruta para que el widget muestre placeholder
        return const SpriteData(
          spritePath: '',
          x: 0,
          y: 0,
          width: SpriteParser.SPRITE_WIDTH,
          height: SpriteParser.SPRITE_HEIGHT,
          variant: '',
          isAutogenerated: true,
        );
      }
      final gameBasePath = await _getGameBasePath();

      // Para fusiones diagonales (mismo pokémon), no aplicar filtro gris
      final isDiagonalFusion = headId == bodyId;

      // Primero intentar con headId
      String autogenPath =
          '$gameBasePath/Graphics/Battlers/spritesheets_autogen/$headId.png';

      if (await File(autogenPath).exists()) {
        final sprite = await spriteParser.extractSpriteByIndex(
          autogenPath,
          bodyId, // Usar bodyId como índice en el sprite autogenerado
          '',
          isAutogenerated:
              true, // SIEMPRE marcar como autogenerado para cálculo correcto de posición
        );

        if (sprite != null) {
          // Para fusiones diagonales, crear una copia sin el filtro autogenerado
          if (isDiagonalFusion) {
            return SpriteData(
              spritePath: sprite.spritePath,
              spriteBytes: sprite.spriteBytes,
              x: sprite.x,
              y: sprite.y,
              width: sprite.width,
              height: sprite.height,
              variant: sprite.variant,
              isAutogenerated:
                  false, // No aplicar filtro gris para fusiones diagonales
            );
          }
          return sprite;
        }
      }

      // Si no funciona con headId, intentar con un cálculo diferente
      // Algunos juegos usan fusionId o otros cálculos
      final fusionId = headId * 1000 + bodyId; // Ejemplo de cálculo
      autogenPath =
          '$gameBasePath/Graphics/Battlers/spritesheets_autogen/$fusionId.png';

      if (await File(autogenPath).exists()) {
        final sprite = await spriteParser.extractSpriteByIndex(
          autogenPath,
          0, // Si es un archivo específico para la fusión, usar índice 0
          '',
          isAutogenerated:
              true, // SIEMPRE marcar como autogenerado para cálculo correcto de posición
        );

        if (sprite != null) {
          // Para fusiones diagonales, crear una copia sin el filtro autogenerado
          if (isDiagonalFusion) {
            return SpriteData(
              spritePath: sprite.spritePath,
              spriteBytes: sprite.spriteBytes,
              x: sprite.x,
              y: sprite.y,
              width: sprite.width,
              height: sprite.height,
              variant: sprite.variant,
              isAutogenerated:
                  false, // No aplicar filtro gris para fusiones diagonales
            );
          }
          return sprite;
        }
      }

      return null;
    } catch (e, s) {
      await logger.logError(
        Exception('getAutogenSprite failed for headId=$headId bodyId=$bodyId error=$e'),
        s,
      );
      return null;
    }
  }

  /// Intenta descargar un spritesheet si no existe localmente
  Future<void> _tryDownloadSpritesheet(
    int headId,
    String spritesheetPath,
    String variant,
  ) async {
    try {
      // Solo intentar descargar si el archivo no existe
      final file = File(spritesheetPath);
      if (!await file.exists()) {
        if (variant.isEmpty) {
          // 1) Desbloquear rápido: asegurar la base solamente
          await spriteDownloadService.downloadSpriteIfNeeded(
            headId: headId,
            localSpritePath: spritesheetPath,
            variant: '',
            type: SpriteType.custom,
          );
          // 2) Prefetch completo en background (no bloquear)
          unawaited(
            spriteDownloadService.downloadAllVariants(
              headId: headId,
              baseLocalPath: spritesheetPath,
              type: SpriteType.custom,
            ),
          );
        } else {
          // Para variantes específicas, descargar solo esa variante
          await spriteDownloadService.downloadSpriteIfNeeded(
            headId: headId,
            localSpritePath: spritesheetPath,
            variant: variant,
            type: SpriteType.custom,
          );
        }
      }
    } catch (e, s) {
      await logger.logError(
        Exception('_tryDownloadSpritesheet failed for headId=$headId variant=$variant path=$spritesheetPath error=$e'),
        s,
      );
    }
  }
}
