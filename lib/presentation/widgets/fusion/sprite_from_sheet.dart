import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:fusion_box/domain/entities/sprite_data.dart';

class SpriteFromSheet extends StatelessWidget {
  final SpriteData spriteData;
  final double? width;
  final double? height;
  final BoxFit fit;

  const SpriteFromSheet({
    super.key,
    required this.spriteData,
    this.width,
    this.height,
    this.fit = BoxFit.contain,
  });

  @override
  Widget build(BuildContext context) {
    Widget imageWidget;

    if (kIsWeb && spriteData.spriteBytes == null && spriteData.spritePath.isNotEmpty) {
      // Renderizar sub-rect del spritesheet remoto con escala correcta
      final double sourceW = spriteData.width.toDouble();
      final double sourceH = spriteData.height.toDouble();
      final double targetW = width ?? sourceW;
      final double targetH = height ?? sourceH;

      // Calcular escala según el fit (usamos contain por defecto en la grid)
      double scaleX = targetW / sourceW;
      double scaleY = targetH / sourceH;
      double scale;
      switch (fit) {
        case BoxFit.fill:
          // Estirar para ocupar todo
          scale = 1.0; // usaremos escalas diferenciadas con Matrix
          break;
        case BoxFit.contain:
        case BoxFit.scaleDown:
          scale = scaleX < scaleY ? scaleX : scaleY;
          break;
        case BoxFit.cover:
          scale = scaleX > scaleY ? scaleX : scaleY;
          break;
        case BoxFit.fitWidth:
          scale = scaleX;
          break;
        case BoxFit.fitHeight:
          scale = scaleY;
          break;
        case BoxFit.none:
          scale = 1.0;
          break;
      }

      // Dimensiones visibles del sprite (tras aplicar fit)
      final double visibleW = fit == BoxFit.fill ? targetW : sourceW * scale;
      final double visibleH = fit == BoxFit.fill ? targetH : sourceH * scale;

      imageWidget = SizedBox(
        width: targetW,
        height: targetH,
        child: Center(
          child: SizedBox(
            width: visibleW,
            height: visibleH,
            child: ClipRect(
              child: OverflowBox(
                minWidth: visibleW,
                minHeight: visibleH,
                maxWidth: double.infinity,
                maxHeight: double.infinity,
                alignment: Alignment.topLeft,
                child: Transform(
                  alignment: Alignment.topLeft,
                  transform: () {
                    // Si BoxFit.fill, permitir escalas separadas en X/Y contra el tamaño objetivo
                    if (fit == BoxFit.fill) {
                      final m = Matrix4.identity();
                      m.translate(-spriteData.x * scaleX, -spriteData.y * scaleY);
                      m.scale(scaleX, scaleY);
                      return m;
                    }
                    final m = Matrix4.identity();
                    m.translate(-spriteData.x * scale, -spriteData.y * scale);
                    m.scale(scale, scale);
                    return m;
                  }(),
                  child: Image.network(
                    spriteData.spritePath,
                    fit: BoxFit.none,
                    filterQuality: FilterQuality.none,
                    errorBuilder: (context, error, stackTrace) {
                      return _webPlaceholder(width: targetW, height: targetH);
                    },
                  ),
                ),
              ),
            ),
          ),
        ),
      );
    } else if (spriteData.spriteBytes != null) {
      imageWidget = Image.memory(
        spriteData.spriteBytes!,
        width: width,
        height: height,
        fit: fit,
        errorBuilder: (context, error, stackTrace) {
          return _genericPlaceholder();
        },
      );
    } else {
      // Web-specific: if path is empty, show a friendly placeholder (used for autogen on web)
      if (kIsWeb) {
        imageWidget = _webPlaceholder(width: width ?? 100, height: height ?? 60);
      } else {
        imageWidget = _genericPlaceholder();
      }
    }

    // Aplicar filtro gris si es un sprite autogenerado
    if (spriteData.isAutogenerated) {
      imageWidget = ColorFiltered(
        colorFilter: const ColorFilter.matrix([
          0.6,
          0.2,
          0.2,
          0,
          0, // Red channel (reducido, con algo de los otros canales)
          0.2,
          0.6,
          0.2,
          0,
          0, // Green channel (reducido, con algo de los otros canales)
          0.2,
          0.2,
          0.6,
          0,
          0, // Blue channel (reducido, con algo de los otros canales)
          0, 0, 0, 1, 0, // Alpha channel (sin cambios)
        ]),
        child: imageWidget,
      );
    }

    return imageWidget;
  }

  Widget _genericPlaceholder() {
    return Container(
      width: width ?? 96,
      height: height ?? 96,
      color: Colors.grey[300],
      child: const Icon(Icons.image_not_supported),
    );
  }

  Widget _webPlaceholder({required double width, required double height}) {
    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: Colors.purple[100],
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: Colors.purple[300]!),
      ),
      child: const Icon(
        Icons.auto_awesome,
        color: Colors.purple,
        size: 20,
      ),
    );
  }
}
