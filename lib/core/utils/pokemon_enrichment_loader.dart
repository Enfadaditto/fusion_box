import 'dart:convert';

import 'package:flutter/services.dart' show rootBundle;
import 'package:fusion_box/core/utils/pokemon_name_normalizer.dart';
import 'package:fusion_box/domain/entities/pokemon.dart';
import 'package:fusion_box/domain/entities/move_learn.dart';

/// Loads enrichment data for Pokemon from `assets/pokemon_full_list.json`.
///
/// The JSON is generated by `tool/generate_pokemon_stats_json.dart` and
/// contains at least: number, name, types, stats, abilities.
class PokemonEnrichmentLoader {
  static final PokemonEnrichmentLoader _instance =
      PokemonEnrichmentLoader._internal();
  factory PokemonEnrichmentLoader() => _instance;
  PokemonEnrichmentLoader._internal();

  Map<int, List<String>>? _abilitiesByNumber;
  Map<String, List<String>>? _abilitiesByNormalizedName;
  List<String>? _allAbilities;

  // Moves catalog
  Map<int, List<String>>? _movesByNumber;
  Map<String, List<String>>? _movesByNormalizedName;
  List<String>? _allMoves;
  // Moves with level info
  Map<int, List<MoveLearn>>? _movesWithLevelByNumber;
  Map<String, List<MoveLearn>>? _movesWithLevelByNormalizedName;

  Future<void> _ensureLoaded() async {
    if (_abilitiesByNumber != null &&
        _abilitiesByNormalizedName != null &&
        _allAbilities != null &&
        _movesByNumber != null &&
        _movesByNormalizedName != null &&
        _allMoves != null &&
        _movesWithLevelByNumber != null &&
        _movesWithLevelByNormalizedName != null) {
      return;
    }

    final String jsonString =
        await rootBundle.loadString('assets/pokemon_full_list.json');
    final List<dynamic> items = json.decode(jsonString) as List<dynamic>;

    final Map<int, List<String>> byNumber = {};
    final Map<String, List<String>> byNormalizedName = {};
    final Set<String> abilitySet = {};
    // Moves structures
    final Map<int, List<String>> movesByNumber = {};
    final Map<String, List<String>> movesByNormalizedName = {};
    final Set<String> moveSet = {};
    // With-level structures
    final Map<int, List<MoveLearn>> movesWithLevelByNumber = {};
    final Map<String, List<MoveLearn>> movesWithLevelByNormalizedName = {};

    for (final dynamic raw in items) {
      if (raw is! Map<String, dynamic>) continue;
      final int? number = raw['number'] as int?;
      final String? name = raw['name'] as String?;
      if (number == null || name == null) continue;

      final List<dynamic>? abilitiesRaw = raw['abilities'] as List<dynamic>?;
      final List<String> abilities = abilitiesRaw == null
          ? const []
          : abilitiesRaw.map((e) => e.toString()).where((e) => e.isNotEmpty).toList();

      byNumber[number] = abilities;
      final String normalized =
          PokemonNameNormalizer.normalizePokemonName(name);
      byNormalizedName[normalized] = abilities;
      abilitySet.addAll(abilities);

      // Parse moves (strings)
      final List<dynamic>? movesRaw = raw['moves'] as List<dynamic>?;
      final List<String> moves = movesRaw == null
          ? const []
          : movesRaw.map((e) => e.toString()).where((e) => e.isNotEmpty).toList();
      movesByNumber[number] = moves;
      movesByNormalizedName[normalized] = moves;
      moveSet.addAll(moves);

      // Parse moves with levels if available in JSON, otherwise fallback using unknown level
      final List<dynamic>? movesByLevelRaw = raw['movesByLevel'] as List<dynamic>?;
      final List<MoveLearn> movesWithLevels = <MoveLearn>[];
      if (movesByLevelRaw != null) {
        for (final dynamic item in movesByLevelRaw) {
          if (item is Map<String, dynamic>) {
            final String n = (item['name'] ?? '').toString();
            final int? lvl = (item['level'] is num) ? (item['level'] as num).toInt() : null;
            if (n.isNotEmpty) {
              movesWithLevels.add(MoveLearn(name: n, level: lvl));
            }
          }
        }
      } else {
        // Fallback: map plain moves to unknown level
        for (final String n in moves) {
          movesWithLevels.add(MoveLearn(name: n, level: null));
        }
      }
      // Sort by level (nulls last), then by name
      movesWithLevels.sort((a, b) {
        if (a.level == null && b.level == null) return a.name.compareTo(b.name);
        if (a.level == null) return 1;
        if (b.level == null) return -1;
        final int cmp = a.level!.compareTo(b.level!);
        if (cmp != 0) return cmp;
        return a.name.compareTo(b.name);
      });
      movesWithLevelByNumber[number] = movesWithLevels;
      movesWithLevelByNormalizedName[normalized] = movesWithLevels;
    }

    final List<String> all = abilitySet.toList()..sort();
    final List<String> allMoves = moveSet.toList()..sort();
    _abilitiesByNumber = byNumber;
    _abilitiesByNormalizedName = byNormalizedName;
    _allAbilities = all;
    _movesByNumber = movesByNumber;
    _movesByNormalizedName = movesByNormalizedName;
    _allMoves = allMoves;
    _movesWithLevelByNumber = movesWithLevelByNumber;
    _movesWithLevelByNormalizedName = movesWithLevelByNormalizedName;
  }

  Future<List<String>> getAllAbilities() async {
    await _ensureLoaded();
    return List<String>.from(_allAbilities!);
  }

  Future<List<String>> getAbilitiesOfPokemon(Pokemon pokemon) async {
    await _ensureLoaded();
    final byNum = _abilitiesByNumber![pokemon.pokedexNumber];
    if (byNum != null) return byNum;
    final normalized =
        PokemonNameNormalizer.normalizePokemonName(pokemon.name);
    final byName = _abilitiesByNormalizedName![normalized];
    return byName ?? const [];
  }

  Future<Set<String>> getCombinedAbilities(
    Pokemon head,
    Pokemon body,
  ) async {
    final a = await getAbilitiesOfPokemon(head);
    final b = await getAbilitiesOfPokemon(body);
    final combined = <String>{}..addAll(a)..addAll(b);
    return combined;
  }

  // MOVES API
  Future<List<String>> getAllMoves() async {
    await _ensureLoaded();
    return List<String>.from(_allMoves!);
  }

  Future<List<String>> getMovesOfPokemon(Pokemon pokemon) async {
    await _ensureLoaded();
    final byNum = _movesByNumber![pokemon.pokedexNumber];
    if (byNum != null) return byNum;
    final normalized = PokemonNameNormalizer.normalizePokemonName(pokemon.name);
    final byName = _movesByNormalizedName![normalized];
    return byName ?? const [];
  }

  Future<List<MoveLearn>> getMovesWithLevelsOfPokemon(Pokemon pokemon) async {
    await _ensureLoaded();
    final byNum = _movesWithLevelByNumber![pokemon.pokedexNumber];
    if (byNum != null) return byNum;
    final normalized = PokemonNameNormalizer.normalizePokemonName(pokemon.name);
    final byName = _movesWithLevelByNormalizedName![normalized];
    return byName ?? const <MoveLearn>[];
  }

  Future<Set<String>> getCombinedMoves(
    Pokemon head,
    Pokemon body,
  ) async {
    final a = await getMovesOfPokemon(head);
    final b = await getMovesOfPokemon(body);
    final combined = <String>{}..addAll(a)..addAll(b);
    return combined;
  }

  Future<List<MoveLearn>> getCombinedMovesWithLevels(
    Pokemon head,
    Pokemon body,
  ) async {
    final a = await getMovesWithLevelsOfPokemon(head);
    final b = await getMovesWithLevelsOfPokemon(body);
    // Merge by lowercase name, keeping the minimum known level (if any)
    final Map<String, MoveLearn> byName = {};
    void addAll(List<MoveLearn> list) {
      for (final MoveLearn m in list) {
        final key = m.name.toLowerCase();
        if (!byName.containsKey(key)) {
          byName[key] = m;
        } else {
          final MoveLearn existing = byName[key]!;
          final int? lvl = _minNullable(existing.level, m.level);
          byName[key] = MoveLearn(name: existing.name, level: lvl);
        }
      }
    }
    addAll(a);
    addAll(b);
    final List<MoveLearn> out = byName.values.toList();
    out.sort((x, y) {
      if (x.level == null && y.level == null) return x.name.compareTo(y.name);
      if (x.level == null) return 1;
      if (y.level == null) return -1;
      final int cmp = x.level!.compareTo(y.level!);
      if (cmp != 0) return cmp;
      return x.name.compareTo(y.name);
    });
    return out;
  }

  int? _minNullable(int? a, int? b) {
    if (a == null) return b;
    if (b == null) return a;
    return a < b ? a : b;
  }

  /// Returns the set of Pokedex numbers of Pokemon that have ALL of the
  /// provided [moves] (case-insensitive match).
  Future<Set<int>> getPokemonNumbersHavingAllMoves(List<String> moves) async {
    await _ensureLoaded();
    if (moves.isEmpty) return const <int>{};
    final required = moves.map((m) => m.toLowerCase()).toList(growable: false);
    final Set<int> result = {};
    _movesByNumber!.forEach((number, pokemonMoves) {
      final lower = pokemonMoves.map((m) => m.toLowerCase()).toSet();
      final ok = required.every(lower.contains);
      if (ok) result.add(number);
    });
    return result;
  }
}


