import 'dart:convert';

import 'package:flutter/services.dart' show rootBundle;
import 'package:fusion_box/core/utils/pokemon_name_normalizer.dart';
import 'package:fusion_box/domain/entities/pokemon.dart';

/// Loads enrichment data for Pokemon from `assets/pokemon_full_list.json`.
///
/// The JSON is generated by `tool/generate_pokemon_stats_json.dart` and
/// contains at least: number, name, types, stats, abilities.
class PokemonEnrichmentLoader {
  static final PokemonEnrichmentLoader _instance =
      PokemonEnrichmentLoader._internal();
  factory PokemonEnrichmentLoader() => _instance;
  PokemonEnrichmentLoader._internal();

  Map<int, List<String>>? _abilitiesByNumber;
  Map<String, List<String>>? _abilitiesByNormalizedName;
  List<String>? _allAbilities;

  // Moves catalog
  Map<int, List<String>>? _movesByNumber;
  Map<String, List<String>>? _movesByNormalizedName;
  List<String>? _allMoves;

  Future<void> _ensureLoaded() async {
    if (_abilitiesByNumber != null &&
        _abilitiesByNormalizedName != null &&
        _allAbilities != null &&
        _movesByNumber != null &&
        _movesByNormalizedName != null &&
        _allMoves != null) {
      return;
    }

    final String jsonString =
        await rootBundle.loadString('assets/pokemon_full_list.json');
    final List<dynamic> items = json.decode(jsonString) as List<dynamic>;

    final Map<int, List<String>> byNumber = {};
    final Map<String, List<String>> byNormalizedName = {};
    final Set<String> abilitySet = {};
    // Moves structures
    final Map<int, List<String>> movesByNumber = {};
    final Map<String, List<String>> movesByNormalizedName = {};
    final Set<String> moveSet = {};

    for (final dynamic raw in items) {
      if (raw is! Map<String, dynamic>) continue;
      final int? number = raw['number'] as int?;
      final String? name = raw['name'] as String?;
      if (number == null || name == null) continue;

      final List<dynamic>? abilitiesRaw = raw['abilities'] as List<dynamic>?;
      final List<String> abilities = abilitiesRaw == null
          ? const []
          : abilitiesRaw.map((e) => e.toString()).where((e) => e.isNotEmpty).toList();

      byNumber[number] = abilities;
      final String normalized =
          PokemonNameNormalizer.normalizePokemonName(name);
      byNormalizedName[normalized] = abilities;
      abilitySet.addAll(abilities);

      // Parse moves
      final List<dynamic>? movesRaw = raw['moves'] as List<dynamic>?;
      final List<String> moves = movesRaw == null
          ? const []
          : movesRaw.map((e) => e.toString()).where((e) => e.isNotEmpty).toList();
      movesByNumber[number] = moves;
      movesByNormalizedName[normalized] = moves;
      moveSet.addAll(moves);
    }

    final List<String> all = abilitySet.toList()..sort();
    final List<String> allMoves = moveSet.toList()..sort();
    _abilitiesByNumber = byNumber;
    _abilitiesByNormalizedName = byNormalizedName;
    _allAbilities = all;
    _movesByNumber = movesByNumber;
    _movesByNormalizedName = movesByNormalizedName;
    _allMoves = allMoves;
  }

  Future<List<String>> getAllAbilities() async {
    await _ensureLoaded();
    return List<String>.from(_allAbilities!);
  }

  Future<List<String>> getAbilitiesOfPokemon(Pokemon pokemon) async {
    await _ensureLoaded();
    final byNum = _abilitiesByNumber![pokemon.pokedexNumber];
    if (byNum != null) return byNum;
    final normalized =
        PokemonNameNormalizer.normalizePokemonName(pokemon.name);
    final byName = _abilitiesByNormalizedName![normalized];
    return byName ?? const [];
  }

  Future<Set<String>> getCombinedAbilities(
    Pokemon head,
    Pokemon body,
  ) async {
    final a = await getAbilitiesOfPokemon(head);
    final b = await getAbilitiesOfPokemon(body);
    final combined = <String>{}..addAll(a)..addAll(b);
    return combined;
  }

  // MOVES API
  Future<List<String>> getAllMoves() async {
    await _ensureLoaded();
    return List<String>.from(_allMoves!);
  }

  Future<List<String>> getMovesOfPokemon(Pokemon pokemon) async {
    await _ensureLoaded();
    final byNum = _movesByNumber![pokemon.pokedexNumber];
    if (byNum != null) return byNum;
    final normalized = PokemonNameNormalizer.normalizePokemonName(pokemon.name);
    final byName = _movesByNormalizedName![normalized];
    return byName ?? const [];
  }

  Future<Set<String>> getCombinedMoves(
    Pokemon head,
    Pokemon body,
  ) async {
    final a = await getMovesOfPokemon(head);
    final b = await getMovesOfPokemon(body);
    final combined = <String>{}..addAll(a)..addAll(b);
    return combined;
  }

  /// Returns the set of Pokedex numbers of Pokemon that have ALL of the
  /// provided [moves] (case-insensitive match).
  Future<Set<int>> getPokemonNumbersHavingAllMoves(List<String> moves) async {
    await _ensureLoaded();
    if (moves.isEmpty) return const <int>{};
    final required = moves.map((m) => m.toLowerCase()).toList(growable: false);
    final Set<int> result = {};
    _movesByNumber!.forEach((number, pokemonMoves) {
      final lower = pokemonMoves.map((m) => m.toLowerCase()).toSet();
      final ok = required.every(lower.contains);
      if (ok) result.add(number);
    });
    return result;
  }
}


