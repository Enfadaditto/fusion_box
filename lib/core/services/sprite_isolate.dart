import 'dart:io';
import 'dart:isolate';
import 'dart:typed_data';

import 'package:image/image.dart' as img;

/// Top-level function to be used with `compute`.
/// Args map must include:
/// - 'path' `String`: spritesheet absolute path
/// - 'indices' `List<int>`: body indices to crop
/// - 'spriteWidth' `int`
/// - 'spriteHeight' `int`
/// - 'spritesPerRow' `int`
/// - 'variant' `String`
/// - 'isAutogenerated' `bool`
Future<List<Map<String, dynamic>>> batchDecodeAndCrop(
  Map<String, dynamic> args,
) async {
  final String path = args['path'] as String;
  final List indicesRaw = args['indices'] as List;
  final List<int> indices = indicesRaw.cast<int>();
  final int spriteWidth = args['spriteWidth'] as int;
  final int spriteHeight = args['spriteHeight'] as int;
  final int spritesPerRow = args['spritesPerRow'] as int;
  final String variant = (args['variant'] as String?) ?? '';
  final bool isAutogenerated = (args['isAutogenerated'] as bool?) ?? false;

  final file = File(path);
  if (!await file.exists()) {
    return const [];
  }

  final Uint8List bytes = await file.readAsBytes();
  final img.Image? sheet = img.decodeImage(bytes);
  if (sheet == null) {
    return const [];
  }

  final List<Map<String, dynamic>> results = [];
  for (final int index in indices) {
    final int col = index % spritesPerRow;
    final int row = index ~/ spritesPerRow;
    final int x = col * spriteWidth;
    final int y = row * spriteHeight;

    if (x + spriteWidth > sheet.width || y + spriteHeight > sheet.height) {
      continue;
    }

    final img.Image sprite = img.copyCrop(
      sheet,
      x: x,
      y: y,
      width: spriteWidth,
      height: spriteHeight,
    );

    if (!_isValidSprite(sprite)) {
      continue;
    }

    final Uint8List pngBytes = Uint8List.fromList(img.encodePng(sprite));
    final TransferableTypedData ttd = TransferableTypedData.fromList([pngBytes]);

    results.add({
      'index': index,
      'x': x,
      'y': y,
      'width': spriteWidth,
      'height': spriteHeight,
      'variant': variant,
      'isAutogenerated': isAutogenerated,
      'path': path,
      'bytes': ttd,
    });
  }

  return results;
}

bool _isValidSprite(img.Image sprite) {
  for (int y = 0; y < sprite.height; y++) {
    for (int x = 0; x < sprite.width; x++) {
      final pixel = sprite.getPixel(x, y);
      if (pixel.a > 0) {
        return true;
      }
    }
  }
  return false;
}


